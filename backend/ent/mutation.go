// Code generated by entc, DO NOT EDIT.

package ent

import (
	"context"
	"fmt"
	"sync"
	"time"

	"github.com/team10/app/ent/department"
	"github.com/team10/app/ent/historytaking"
	"github.com/team10/app/ent/nurse"
	"github.com/team10/app/ent/patientrecord"
	"github.com/team10/app/ent/symptomseverity"
	"github.com/team10/app/ent/user"

	"github.com/facebookincubator/ent"
)

const (
	// Operation types.
	OpCreate    = ent.OpCreate
	OpDelete    = ent.OpDelete
	OpDeleteOne = ent.OpDeleteOne
	OpUpdate    = ent.OpUpdate
	OpUpdateOne = ent.OpUpdateOne

	// Node types.
	TypeDepartment      = "Department"
	TypeHistorytaking   = "Historytaking"
	TypeNurse           = "Nurse"
	TypePatientrecord   = "Patientrecord"
	TypeSymptomseverity = "Symptomseverity"
	TypeUser            = "User"
)

// DepartmentMutation represents an operation that mutate the Departments
// nodes in the graph.
type DepartmentMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	department           *string
	clearedFields        map[string]struct{}
	historytaking        map[int]struct{}
	removedhistorytaking map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Department, error)
}

var _ ent.Mutation = (*DepartmentMutation)(nil)

// departmentOption allows to manage the mutation configuration using functional options.
type departmentOption func(*DepartmentMutation)

// newDepartmentMutation creates new mutation for $n.Name.
func newDepartmentMutation(c config, op Op, opts ...departmentOption) *DepartmentMutation {
	m := &DepartmentMutation{
		config:        c,
		op:            op,
		typ:           TypeDepartment,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withDepartmentID sets the id field of the mutation.
func withDepartmentID(id int) departmentOption {
	return func(m *DepartmentMutation) {
		var (
			err   error
			once  sync.Once
			value *Department
		)
		m.oldValue = func(ctx context.Context) (*Department, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Department.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withDepartment sets the old Department of the mutation.
func withDepartment(node *Department) departmentOption {
	return func(m *DepartmentMutation) {
		m.oldValue = func(context.Context) (*Department, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m DepartmentMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m DepartmentMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *DepartmentMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetDepartment sets the department field.
func (m *DepartmentMutation) SetDepartment(s string) {
	m.department = &s
}

// Department returns the department value in the mutation.
func (m *DepartmentMutation) Department() (r string, exists bool) {
	v := m.department
	if v == nil {
		return
	}
	return *v, true
}

// OldDepartment returns the old department value of the Department.
// If the Department object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *DepartmentMutation) OldDepartment(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDepartment is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDepartment requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDepartment: %w", err)
	}
	return oldValue.Department, nil
}

// ResetDepartment reset all changes of the "department" field.
func (m *DepartmentMutation) ResetDepartment() {
	m.department = nil
}

// AddHistorytakingIDs adds the historytaking edge to Historytaking by ids.
func (m *DepartmentMutation) AddHistorytakingIDs(ids ...int) {
	if m.historytaking == nil {
		m.historytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.historytaking[ids[i]] = struct{}{}
	}
}

// RemoveHistorytakingIDs removes the historytaking edge to Historytaking by ids.
func (m *DepartmentMutation) RemoveHistorytakingIDs(ids ...int) {
	if m.removedhistorytaking == nil {
		m.removedhistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhistorytaking[ids[i]] = struct{}{}
	}
}

// RemovedHistorytaking returns the removed ids of historytaking.
func (m *DepartmentMutation) RemovedHistorytakingIDs() (ids []int) {
	for id := range m.removedhistorytaking {
		ids = append(ids, id)
	}
	return
}

// HistorytakingIDs returns the historytaking ids in the mutation.
func (m *DepartmentMutation) HistorytakingIDs() (ids []int) {
	for id := range m.historytaking {
		ids = append(ids, id)
	}
	return
}

// ResetHistorytaking reset all changes of the "historytaking" edge.
func (m *DepartmentMutation) ResetHistorytaking() {
	m.historytaking = nil
	m.removedhistorytaking = nil
}

// Op returns the operation name.
func (m *DepartmentMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Department).
func (m *DepartmentMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *DepartmentMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.department != nil {
		fields = append(fields, department.FieldDepartment)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *DepartmentMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case department.FieldDepartment:
		return m.Department()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *DepartmentMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case department.FieldDepartment:
		return m.OldDepartment(ctx)
	}
	return nil, fmt.Errorf("unknown Department field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) SetField(name string, value ent.Value) error {
	switch name {
	case department.FieldDepartment:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDepartment(v)
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *DepartmentMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *DepartmentMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *DepartmentMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Department numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *DepartmentMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *DepartmentMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *DepartmentMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Department nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *DepartmentMutation) ResetField(name string) error {
	switch name {
	case department.FieldDepartment:
		m.ResetDepartment()
		return nil
	}
	return fmt.Errorf("unknown Department field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *DepartmentMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.historytaking != nil {
		edges = append(edges, department.EdgeHistorytaking)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *DepartmentMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.historytaking))
		for id := range m.historytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *DepartmentMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedhistorytaking != nil {
		edges = append(edges, department.EdgeHistorytaking)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *DepartmentMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case department.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.removedhistorytaking))
		for id := range m.removedhistorytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *DepartmentMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *DepartmentMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *DepartmentMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Department unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *DepartmentMutation) ResetEdge(name string) error {
	switch name {
	case department.EdgeHistorytaking:
		m.ResetHistorytaking()
		return nil
	}
	return fmt.Errorf("unknown Department edge %s", name)
}

// HistorytakingMutation represents an operation that mutate the Historytakings
// nodes in the graph.
type HistorytakingMutation struct {
	config
	op                     Op
	typ                    string
	id                     *int
	hight                  *float32
	addhight               *float32
	weight                 *float32
	addweight              *float32
	temp                   *float32
	addtemp                *float32
	pulse                  *int
	addpulse               *int
	respiration            *int
	addrespiration         *int
	bp                     *int
	addbp                  *int
	oxygen                 *string
	symptom                *string
	datetime               *time.Time
	clearedFields          map[string]struct{}
	nurse                  *int
	clearednurse           bool
	department             *int
	cleareddepartment      bool
	symptomseverity        *int
	clearedsymptomseverity bool
	patientrecord          *int
	clearedpatientrecord   bool
	done                   bool
	oldValue               func(context.Context) (*Historytaking, error)
}

var _ ent.Mutation = (*HistorytakingMutation)(nil)

// historytakingOption allows to manage the mutation configuration using functional options.
type historytakingOption func(*HistorytakingMutation)

// newHistorytakingMutation creates new mutation for $n.Name.
func newHistorytakingMutation(c config, op Op, opts ...historytakingOption) *HistorytakingMutation {
	m := &HistorytakingMutation{
		config:        c,
		op:            op,
		typ:           TypeHistorytaking,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withHistorytakingID sets the id field of the mutation.
func withHistorytakingID(id int) historytakingOption {
	return func(m *HistorytakingMutation) {
		var (
			err   error
			once  sync.Once
			value *Historytaking
		)
		m.oldValue = func(ctx context.Context) (*Historytaking, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Historytaking.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withHistorytaking sets the old Historytaking of the mutation.
func withHistorytaking(node *Historytaking) historytakingOption {
	return func(m *HistorytakingMutation) {
		m.oldValue = func(context.Context) (*Historytaking, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m HistorytakingMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m HistorytakingMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *HistorytakingMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetHight sets the hight field.
func (m *HistorytakingMutation) SetHight(f float32) {
	m.hight = &f
	m.addhight = nil
}

// Hight returns the hight value in the mutation.
func (m *HistorytakingMutation) Hight() (r float32, exists bool) {
	v := m.hight
	if v == nil {
		return
	}
	return *v, true
}

// OldHight returns the old hight value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldHight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldHight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldHight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldHight: %w", err)
	}
	return oldValue.Hight, nil
}

// AddHight adds f to hight.
func (m *HistorytakingMutation) AddHight(f float32) {
	if m.addhight != nil {
		*m.addhight += f
	} else {
		m.addhight = &f
	}
}

// AddedHight returns the value that was added to the hight field in this mutation.
func (m *HistorytakingMutation) AddedHight() (r float32, exists bool) {
	v := m.addhight
	if v == nil {
		return
	}
	return *v, true
}

// ResetHight reset all changes of the "hight" field.
func (m *HistorytakingMutation) ResetHight() {
	m.hight = nil
	m.addhight = nil
}

// SetWeight sets the weight field.
func (m *HistorytakingMutation) SetWeight(f float32) {
	m.weight = &f
	m.addweight = nil
}

// Weight returns the weight value in the mutation.
func (m *HistorytakingMutation) Weight() (r float32, exists bool) {
	v := m.weight
	if v == nil {
		return
	}
	return *v, true
}

// OldWeight returns the old weight value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldWeight(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldWeight is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldWeight requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldWeight: %w", err)
	}
	return oldValue.Weight, nil
}

// AddWeight adds f to weight.
func (m *HistorytakingMutation) AddWeight(f float32) {
	if m.addweight != nil {
		*m.addweight += f
	} else {
		m.addweight = &f
	}
}

// AddedWeight returns the value that was added to the weight field in this mutation.
func (m *HistorytakingMutation) AddedWeight() (r float32, exists bool) {
	v := m.addweight
	if v == nil {
		return
	}
	return *v, true
}

// ResetWeight reset all changes of the "weight" field.
func (m *HistorytakingMutation) ResetWeight() {
	m.weight = nil
	m.addweight = nil
}

// SetTemp sets the temp field.
func (m *HistorytakingMutation) SetTemp(f float32) {
	m.temp = &f
	m.addtemp = nil
}

// Temp returns the temp value in the mutation.
func (m *HistorytakingMutation) Temp() (r float32, exists bool) {
	v := m.temp
	if v == nil {
		return
	}
	return *v, true
}

// OldTemp returns the old temp value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldTemp(ctx context.Context) (v float32, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldTemp is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldTemp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldTemp: %w", err)
	}
	return oldValue.Temp, nil
}

// AddTemp adds f to temp.
func (m *HistorytakingMutation) AddTemp(f float32) {
	if m.addtemp != nil {
		*m.addtemp += f
	} else {
		m.addtemp = &f
	}
}

// AddedTemp returns the value that was added to the temp field in this mutation.
func (m *HistorytakingMutation) AddedTemp() (r float32, exists bool) {
	v := m.addtemp
	if v == nil {
		return
	}
	return *v, true
}

// ResetTemp reset all changes of the "temp" field.
func (m *HistorytakingMutation) ResetTemp() {
	m.temp = nil
	m.addtemp = nil
}

// SetPulse sets the pulse field.
func (m *HistorytakingMutation) SetPulse(i int) {
	m.pulse = &i
	m.addpulse = nil
}

// Pulse returns the pulse value in the mutation.
func (m *HistorytakingMutation) Pulse() (r int, exists bool) {
	v := m.pulse
	if v == nil {
		return
	}
	return *v, true
}

// OldPulse returns the old pulse value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldPulse(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPulse is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPulse requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPulse: %w", err)
	}
	return oldValue.Pulse, nil
}

// AddPulse adds i to pulse.
func (m *HistorytakingMutation) AddPulse(i int) {
	if m.addpulse != nil {
		*m.addpulse += i
	} else {
		m.addpulse = &i
	}
}

// AddedPulse returns the value that was added to the pulse field in this mutation.
func (m *HistorytakingMutation) AddedPulse() (r int, exists bool) {
	v := m.addpulse
	if v == nil {
		return
	}
	return *v, true
}

// ResetPulse reset all changes of the "pulse" field.
func (m *HistorytakingMutation) ResetPulse() {
	m.pulse = nil
	m.addpulse = nil
}

// SetRespiration sets the respiration field.
func (m *HistorytakingMutation) SetRespiration(i int) {
	m.respiration = &i
	m.addrespiration = nil
}

// Respiration returns the respiration value in the mutation.
func (m *HistorytakingMutation) Respiration() (r int, exists bool) {
	v := m.respiration
	if v == nil {
		return
	}
	return *v, true
}

// OldRespiration returns the old respiration value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldRespiration(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldRespiration is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldRespiration requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldRespiration: %w", err)
	}
	return oldValue.Respiration, nil
}

// AddRespiration adds i to respiration.
func (m *HistorytakingMutation) AddRespiration(i int) {
	if m.addrespiration != nil {
		*m.addrespiration += i
	} else {
		m.addrespiration = &i
	}
}

// AddedRespiration returns the value that was added to the respiration field in this mutation.
func (m *HistorytakingMutation) AddedRespiration() (r int, exists bool) {
	v := m.addrespiration
	if v == nil {
		return
	}
	return *v, true
}

// ResetRespiration reset all changes of the "respiration" field.
func (m *HistorytakingMutation) ResetRespiration() {
	m.respiration = nil
	m.addrespiration = nil
}

// SetBp sets the bp field.
func (m *HistorytakingMutation) SetBp(i int) {
	m.bp = &i
	m.addbp = nil
}

// Bp returns the bp value in the mutation.
func (m *HistorytakingMutation) Bp() (r int, exists bool) {
	v := m.bp
	if v == nil {
		return
	}
	return *v, true
}

// OldBp returns the old bp value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldBp(ctx context.Context) (v int, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldBp is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldBp requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldBp: %w", err)
	}
	return oldValue.Bp, nil
}

// AddBp adds i to bp.
func (m *HistorytakingMutation) AddBp(i int) {
	if m.addbp != nil {
		*m.addbp += i
	} else {
		m.addbp = &i
	}
}

// AddedBp returns the value that was added to the bp field in this mutation.
func (m *HistorytakingMutation) AddedBp() (r int, exists bool) {
	v := m.addbp
	if v == nil {
		return
	}
	return *v, true
}

// ResetBp reset all changes of the "bp" field.
func (m *HistorytakingMutation) ResetBp() {
	m.bp = nil
	m.addbp = nil
}

// SetOxygen sets the oxygen field.
func (m *HistorytakingMutation) SetOxygen(s string) {
	m.oxygen = &s
}

// Oxygen returns the oxygen value in the mutation.
func (m *HistorytakingMutation) Oxygen() (r string, exists bool) {
	v := m.oxygen
	if v == nil {
		return
	}
	return *v, true
}

// OldOxygen returns the old oxygen value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldOxygen(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldOxygen is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldOxygen requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldOxygen: %w", err)
	}
	return oldValue.Oxygen, nil
}

// ResetOxygen reset all changes of the "oxygen" field.
func (m *HistorytakingMutation) ResetOxygen() {
	m.oxygen = nil
}

// SetSymptom sets the symptom field.
func (m *HistorytakingMutation) SetSymptom(s string) {
	m.symptom = &s
}

// Symptom returns the symptom value in the mutation.
func (m *HistorytakingMutation) Symptom() (r string, exists bool) {
	v := m.symptom
	if v == nil {
		return
	}
	return *v, true
}

// OldSymptom returns the old symptom value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldSymptom(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSymptom is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSymptom requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymptom: %w", err)
	}
	return oldValue.Symptom, nil
}

// ResetSymptom reset all changes of the "symptom" field.
func (m *HistorytakingMutation) ResetSymptom() {
	m.symptom = nil
}

// SetDatetime sets the datetime field.
func (m *HistorytakingMutation) SetDatetime(t time.Time) {
	m.datetime = &t
}

// Datetime returns the datetime value in the mutation.
func (m *HistorytakingMutation) Datetime() (r time.Time, exists bool) {
	v := m.datetime
	if v == nil {
		return
	}
	return *v, true
}

// OldDatetime returns the old datetime value of the Historytaking.
// If the Historytaking object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *HistorytakingMutation) OldDatetime(ctx context.Context) (v time.Time, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldDatetime is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldDatetime requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldDatetime: %w", err)
	}
	return oldValue.Datetime, nil
}

// ResetDatetime reset all changes of the "datetime" field.
func (m *HistorytakingMutation) ResetDatetime() {
	m.datetime = nil
}

// SetNurseID sets the nurse edge to Nurse by id.
func (m *HistorytakingMutation) SetNurseID(id int) {
	m.nurse = &id
}

// ClearNurse clears the nurse edge to Nurse.
func (m *HistorytakingMutation) ClearNurse() {
	m.clearednurse = true
}

// NurseCleared returns if the edge nurse was cleared.
func (m *HistorytakingMutation) NurseCleared() bool {
	return m.clearednurse
}

// NurseID returns the nurse id in the mutation.
func (m *HistorytakingMutation) NurseID() (id int, exists bool) {
	if m.nurse != nil {
		return *m.nurse, true
	}
	return
}

// NurseIDs returns the nurse ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// NurseID instead. It exists only for internal usage by the builders.
func (m *HistorytakingMutation) NurseIDs() (ids []int) {
	if id := m.nurse; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetNurse reset all changes of the "nurse" edge.
func (m *HistorytakingMutation) ResetNurse() {
	m.nurse = nil
	m.clearednurse = false
}

// SetDepartmentID sets the department edge to Department by id.
func (m *HistorytakingMutation) SetDepartmentID(id int) {
	m.department = &id
}

// ClearDepartment clears the department edge to Department.
func (m *HistorytakingMutation) ClearDepartment() {
	m.cleareddepartment = true
}

// DepartmentCleared returns if the edge department was cleared.
func (m *HistorytakingMutation) DepartmentCleared() bool {
	return m.cleareddepartment
}

// DepartmentID returns the department id in the mutation.
func (m *HistorytakingMutation) DepartmentID() (id int, exists bool) {
	if m.department != nil {
		return *m.department, true
	}
	return
}

// DepartmentIDs returns the department ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// DepartmentID instead. It exists only for internal usage by the builders.
func (m *HistorytakingMutation) DepartmentIDs() (ids []int) {
	if id := m.department; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetDepartment reset all changes of the "department" edge.
func (m *HistorytakingMutation) ResetDepartment() {
	m.department = nil
	m.cleareddepartment = false
}

// SetSymptomseverityID sets the symptomseverity edge to Symptomseverity by id.
func (m *HistorytakingMutation) SetSymptomseverityID(id int) {
	m.symptomseverity = &id
}

// ClearSymptomseverity clears the symptomseverity edge to Symptomseverity.
func (m *HistorytakingMutation) ClearSymptomseverity() {
	m.clearedsymptomseverity = true
}

// SymptomseverityCleared returns if the edge symptomseverity was cleared.
func (m *HistorytakingMutation) SymptomseverityCleared() bool {
	return m.clearedsymptomseverity
}

// SymptomseverityID returns the symptomseverity id in the mutation.
func (m *HistorytakingMutation) SymptomseverityID() (id int, exists bool) {
	if m.symptomseverity != nil {
		return *m.symptomseverity, true
	}
	return
}

// SymptomseverityIDs returns the symptomseverity ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// SymptomseverityID instead. It exists only for internal usage by the builders.
func (m *HistorytakingMutation) SymptomseverityIDs() (ids []int) {
	if id := m.symptomseverity; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetSymptomseverity reset all changes of the "symptomseverity" edge.
func (m *HistorytakingMutation) ResetSymptomseverity() {
	m.symptomseverity = nil
	m.clearedsymptomseverity = false
}

// SetPatientrecordID sets the patientrecord edge to Patientrecord by id.
func (m *HistorytakingMutation) SetPatientrecordID(id int) {
	m.patientrecord = &id
}

// ClearPatientrecord clears the patientrecord edge to Patientrecord.
func (m *HistorytakingMutation) ClearPatientrecord() {
	m.clearedpatientrecord = true
}

// PatientrecordCleared returns if the edge patientrecord was cleared.
func (m *HistorytakingMutation) PatientrecordCleared() bool {
	return m.clearedpatientrecord
}

// PatientrecordID returns the patientrecord id in the mutation.
func (m *HistorytakingMutation) PatientrecordID() (id int, exists bool) {
	if m.patientrecord != nil {
		return *m.patientrecord, true
	}
	return
}

// PatientrecordIDs returns the patientrecord ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// PatientrecordID instead. It exists only for internal usage by the builders.
func (m *HistorytakingMutation) PatientrecordIDs() (ids []int) {
	if id := m.patientrecord; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetPatientrecord reset all changes of the "patientrecord" edge.
func (m *HistorytakingMutation) ResetPatientrecord() {
	m.patientrecord = nil
	m.clearedpatientrecord = false
}

// Op returns the operation name.
func (m *HistorytakingMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Historytaking).
func (m *HistorytakingMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *HistorytakingMutation) Fields() []string {
	fields := make([]string, 0, 9)
	if m.hight != nil {
		fields = append(fields, historytaking.FieldHight)
	}
	if m.weight != nil {
		fields = append(fields, historytaking.FieldWeight)
	}
	if m.temp != nil {
		fields = append(fields, historytaking.FieldTemp)
	}
	if m.pulse != nil {
		fields = append(fields, historytaking.FieldPulse)
	}
	if m.respiration != nil {
		fields = append(fields, historytaking.FieldRespiration)
	}
	if m.bp != nil {
		fields = append(fields, historytaking.FieldBp)
	}
	if m.oxygen != nil {
		fields = append(fields, historytaking.FieldOxygen)
	}
	if m.symptom != nil {
		fields = append(fields, historytaking.FieldSymptom)
	}
	if m.datetime != nil {
		fields = append(fields, historytaking.FieldDatetime)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *HistorytakingMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case historytaking.FieldHight:
		return m.Hight()
	case historytaking.FieldWeight:
		return m.Weight()
	case historytaking.FieldTemp:
		return m.Temp()
	case historytaking.FieldPulse:
		return m.Pulse()
	case historytaking.FieldRespiration:
		return m.Respiration()
	case historytaking.FieldBp:
		return m.Bp()
	case historytaking.FieldOxygen:
		return m.Oxygen()
	case historytaking.FieldSymptom:
		return m.Symptom()
	case historytaking.FieldDatetime:
		return m.Datetime()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *HistorytakingMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case historytaking.FieldHight:
		return m.OldHight(ctx)
	case historytaking.FieldWeight:
		return m.OldWeight(ctx)
	case historytaking.FieldTemp:
		return m.OldTemp(ctx)
	case historytaking.FieldPulse:
		return m.OldPulse(ctx)
	case historytaking.FieldRespiration:
		return m.OldRespiration(ctx)
	case historytaking.FieldBp:
		return m.OldBp(ctx)
	case historytaking.FieldOxygen:
		return m.OldOxygen(ctx)
	case historytaking.FieldSymptom:
		return m.OldSymptom(ctx)
	case historytaking.FieldDatetime:
		return m.OldDatetime(ctx)
	}
	return nil, fmt.Errorf("unknown Historytaking field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HistorytakingMutation) SetField(name string, value ent.Value) error {
	switch name {
	case historytaking.FieldHight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetHight(v)
		return nil
	case historytaking.FieldWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetWeight(v)
		return nil
	case historytaking.FieldTemp:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetTemp(v)
		return nil
	case historytaking.FieldPulse:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPulse(v)
		return nil
	case historytaking.FieldRespiration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetRespiration(v)
		return nil
	case historytaking.FieldBp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetBp(v)
		return nil
	case historytaking.FieldOxygen:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetOxygen(v)
		return nil
	case historytaking.FieldSymptom:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymptom(v)
		return nil
	case historytaking.FieldDatetime:
		v, ok := value.(time.Time)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetDatetime(v)
		return nil
	}
	return fmt.Errorf("unknown Historytaking field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *HistorytakingMutation) AddedFields() []string {
	var fields []string
	if m.addhight != nil {
		fields = append(fields, historytaking.FieldHight)
	}
	if m.addweight != nil {
		fields = append(fields, historytaking.FieldWeight)
	}
	if m.addtemp != nil {
		fields = append(fields, historytaking.FieldTemp)
	}
	if m.addpulse != nil {
		fields = append(fields, historytaking.FieldPulse)
	}
	if m.addrespiration != nil {
		fields = append(fields, historytaking.FieldRespiration)
	}
	if m.addbp != nil {
		fields = append(fields, historytaking.FieldBp)
	}
	return fields
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *HistorytakingMutation) AddedField(name string) (ent.Value, bool) {
	switch name {
	case historytaking.FieldHight:
		return m.AddedHight()
	case historytaking.FieldWeight:
		return m.AddedWeight()
	case historytaking.FieldTemp:
		return m.AddedTemp()
	case historytaking.FieldPulse:
		return m.AddedPulse()
	case historytaking.FieldRespiration:
		return m.AddedRespiration()
	case historytaking.FieldBp:
		return m.AddedBp()
	}
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *HistorytakingMutation) AddField(name string, value ent.Value) error {
	switch name {
	case historytaking.FieldHight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddHight(v)
		return nil
	case historytaking.FieldWeight:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddWeight(v)
		return nil
	case historytaking.FieldTemp:
		v, ok := value.(float32)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddTemp(v)
		return nil
	case historytaking.FieldPulse:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddPulse(v)
		return nil
	case historytaking.FieldRespiration:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddRespiration(v)
		return nil
	case historytaking.FieldBp:
		v, ok := value.(int)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.AddBp(v)
		return nil
	}
	return fmt.Errorf("unknown Historytaking numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *HistorytakingMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *HistorytakingMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *HistorytakingMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Historytaking nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *HistorytakingMutation) ResetField(name string) error {
	switch name {
	case historytaking.FieldHight:
		m.ResetHight()
		return nil
	case historytaking.FieldWeight:
		m.ResetWeight()
		return nil
	case historytaking.FieldTemp:
		m.ResetTemp()
		return nil
	case historytaking.FieldPulse:
		m.ResetPulse()
		return nil
	case historytaking.FieldRespiration:
		m.ResetRespiration()
		return nil
	case historytaking.FieldBp:
		m.ResetBp()
		return nil
	case historytaking.FieldOxygen:
		m.ResetOxygen()
		return nil
	case historytaking.FieldSymptom:
		m.ResetSymptom()
		return nil
	case historytaking.FieldDatetime:
		m.ResetDatetime()
		return nil
	}
	return fmt.Errorf("unknown Historytaking field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *HistorytakingMutation) AddedEdges() []string {
	edges := make([]string, 0, 4)
	if m.nurse != nil {
		edges = append(edges, historytaking.EdgeNurse)
	}
	if m.department != nil {
		edges = append(edges, historytaking.EdgeDepartment)
	}
	if m.symptomseverity != nil {
		edges = append(edges, historytaking.EdgeSymptomseverity)
	}
	if m.patientrecord != nil {
		edges = append(edges, historytaking.EdgePatientrecord)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *HistorytakingMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case historytaking.EdgeNurse:
		if id := m.nurse; id != nil {
			return []ent.Value{*id}
		}
	case historytaking.EdgeDepartment:
		if id := m.department; id != nil {
			return []ent.Value{*id}
		}
	case historytaking.EdgeSymptomseverity:
		if id := m.symptomseverity; id != nil {
			return []ent.Value{*id}
		}
	case historytaking.EdgePatientrecord:
		if id := m.patientrecord; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *HistorytakingMutation) RemovedEdges() []string {
	edges := make([]string, 0, 4)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *HistorytakingMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *HistorytakingMutation) ClearedEdges() []string {
	edges := make([]string, 0, 4)
	if m.clearednurse {
		edges = append(edges, historytaking.EdgeNurse)
	}
	if m.cleareddepartment {
		edges = append(edges, historytaking.EdgeDepartment)
	}
	if m.clearedsymptomseverity {
		edges = append(edges, historytaking.EdgeSymptomseverity)
	}
	if m.clearedpatientrecord {
		edges = append(edges, historytaking.EdgePatientrecord)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *HistorytakingMutation) EdgeCleared(name string) bool {
	switch name {
	case historytaking.EdgeNurse:
		return m.clearednurse
	case historytaking.EdgeDepartment:
		return m.cleareddepartment
	case historytaking.EdgeSymptomseverity:
		return m.clearedsymptomseverity
	case historytaking.EdgePatientrecord:
		return m.clearedpatientrecord
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *HistorytakingMutation) ClearEdge(name string) error {
	switch name {
	case historytaking.EdgeNurse:
		m.ClearNurse()
		return nil
	case historytaking.EdgeDepartment:
		m.ClearDepartment()
		return nil
	case historytaking.EdgeSymptomseverity:
		m.ClearSymptomseverity()
		return nil
	case historytaking.EdgePatientrecord:
		m.ClearPatientrecord()
		return nil
	}
	return fmt.Errorf("unknown Historytaking unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *HistorytakingMutation) ResetEdge(name string) error {
	switch name {
	case historytaking.EdgeNurse:
		m.ResetNurse()
		return nil
	case historytaking.EdgeDepartment:
		m.ResetDepartment()
		return nil
	case historytaking.EdgeSymptomseverity:
		m.ResetSymptomseverity()
		return nil
	case historytaking.EdgePatientrecord:
		m.ResetPatientrecord()
		return nil
	}
	return fmt.Errorf("unknown Historytaking edge %s", name)
}

// NurseMutation represents an operation that mutate the Nurses
// nodes in the graph.
type NurseMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	name                 *string
	nursinglicense       *string
	position             *string
	clearedFields        map[string]struct{}
	historytaking        map[int]struct{}
	removedhistorytaking map[int]struct{}
	user                 *int
	cleareduser          bool
	done                 bool
	oldValue             func(context.Context) (*Nurse, error)
}

var _ ent.Mutation = (*NurseMutation)(nil)

// nurseOption allows to manage the mutation configuration using functional options.
type nurseOption func(*NurseMutation)

// newNurseMutation creates new mutation for $n.Name.
func newNurseMutation(c config, op Op, opts ...nurseOption) *NurseMutation {
	m := &NurseMutation{
		config:        c,
		op:            op,
		typ:           TypeNurse,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withNurseID sets the id field of the mutation.
func withNurseID(id int) nurseOption {
	return func(m *NurseMutation) {
		var (
			err   error
			once  sync.Once
			value *Nurse
		)
		m.oldValue = func(ctx context.Context) (*Nurse, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Nurse.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withNurse sets the old Nurse of the mutation.
func withNurse(node *Nurse) nurseOption {
	return func(m *NurseMutation) {
		m.oldValue = func(context.Context) (*Nurse, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m NurseMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m NurseMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *NurseMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the name field.
func (m *NurseMutation) SetName(s string) {
	m.name = &s
}

// Name returns the name value in the mutation.
func (m *NurseMutation) Name() (r string, exists bool) {
	v := m.name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old name value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "name" field.
func (m *NurseMutation) ResetName() {
	m.name = nil
}

// SetNursinglicense sets the nursinglicense field.
func (m *NurseMutation) SetNursinglicense(s string) {
	m.nursinglicense = &s
}

// Nursinglicense returns the nursinglicense value in the mutation.
func (m *NurseMutation) Nursinglicense() (r string, exists bool) {
	v := m.nursinglicense
	if v == nil {
		return
	}
	return *v, true
}

// OldNursinglicense returns the old nursinglicense value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldNursinglicense(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldNursinglicense is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldNursinglicense requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldNursinglicense: %w", err)
	}
	return oldValue.Nursinglicense, nil
}

// ResetNursinglicense reset all changes of the "nursinglicense" field.
func (m *NurseMutation) ResetNursinglicense() {
	m.nursinglicense = nil
}

// SetPosition sets the position field.
func (m *NurseMutation) SetPosition(s string) {
	m.position = &s
}

// Position returns the position value in the mutation.
func (m *NurseMutation) Position() (r string, exists bool) {
	v := m.position
	if v == nil {
		return
	}
	return *v, true
}

// OldPosition returns the old position value of the Nurse.
// If the Nurse object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *NurseMutation) OldPosition(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPosition is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPosition requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPosition: %w", err)
	}
	return oldValue.Position, nil
}

// ResetPosition reset all changes of the "position" field.
func (m *NurseMutation) ResetPosition() {
	m.position = nil
}

// AddHistorytakingIDs adds the historytaking edge to Historytaking by ids.
func (m *NurseMutation) AddHistorytakingIDs(ids ...int) {
	if m.historytaking == nil {
		m.historytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.historytaking[ids[i]] = struct{}{}
	}
}

// RemoveHistorytakingIDs removes the historytaking edge to Historytaking by ids.
func (m *NurseMutation) RemoveHistorytakingIDs(ids ...int) {
	if m.removedhistorytaking == nil {
		m.removedhistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhistorytaking[ids[i]] = struct{}{}
	}
}

// RemovedHistorytaking returns the removed ids of historytaking.
func (m *NurseMutation) RemovedHistorytakingIDs() (ids []int) {
	for id := range m.removedhistorytaking {
		ids = append(ids, id)
	}
	return
}

// HistorytakingIDs returns the historytaking ids in the mutation.
func (m *NurseMutation) HistorytakingIDs() (ids []int) {
	for id := range m.historytaking {
		ids = append(ids, id)
	}
	return
}

// ResetHistorytaking reset all changes of the "historytaking" edge.
func (m *NurseMutation) ResetHistorytaking() {
	m.historytaking = nil
	m.removedhistorytaking = nil
}

// SetUserID sets the user edge to User by id.
func (m *NurseMutation) SetUserID(id int) {
	m.user = &id
}

// ClearUser clears the user edge to User.
func (m *NurseMutation) ClearUser() {
	m.cleareduser = true
}

// UserCleared returns if the edge user was cleared.
func (m *NurseMutation) UserCleared() bool {
	return m.cleareduser
}

// UserID returns the user id in the mutation.
func (m *NurseMutation) UserID() (id int, exists bool) {
	if m.user != nil {
		return *m.user, true
	}
	return
}

// UserIDs returns the user ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// UserID instead. It exists only for internal usage by the builders.
func (m *NurseMutation) UserIDs() (ids []int) {
	if id := m.user; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetUser reset all changes of the "user" edge.
func (m *NurseMutation) ResetUser() {
	m.user = nil
	m.cleareduser = false
}

// Op returns the operation name.
func (m *NurseMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Nurse).
func (m *NurseMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *NurseMutation) Fields() []string {
	fields := make([]string, 0, 3)
	if m.name != nil {
		fields = append(fields, nurse.FieldName)
	}
	if m.nursinglicense != nil {
		fields = append(fields, nurse.FieldNursinglicense)
	}
	if m.position != nil {
		fields = append(fields, nurse.FieldPosition)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *NurseMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case nurse.FieldName:
		return m.Name()
	case nurse.FieldNursinglicense:
		return m.Nursinglicense()
	case nurse.FieldPosition:
		return m.Position()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *NurseMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case nurse.FieldName:
		return m.OldName(ctx)
	case nurse.FieldNursinglicense:
		return m.OldNursinglicense(ctx)
	case nurse.FieldPosition:
		return m.OldPosition(ctx)
	}
	return nil, fmt.Errorf("unknown Nurse field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NurseMutation) SetField(name string, value ent.Value) error {
	switch name {
	case nurse.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	case nurse.FieldNursinglicense:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetNursinglicense(v)
		return nil
	case nurse.FieldPosition:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPosition(v)
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *NurseMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *NurseMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *NurseMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Nurse numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *NurseMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *NurseMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *NurseMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Nurse nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *NurseMutation) ResetField(name string) error {
	switch name {
	case nurse.FieldName:
		m.ResetName()
		return nil
	case nurse.FieldNursinglicense:
		m.ResetNursinglicense()
		return nil
	case nurse.FieldPosition:
		m.ResetPosition()
		return nil
	}
	return fmt.Errorf("unknown Nurse field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *NurseMutation) AddedEdges() []string {
	edges := make([]string, 0, 2)
	if m.historytaking != nil {
		edges = append(edges, nurse.EdgeHistorytaking)
	}
	if m.user != nil {
		edges = append(edges, nurse.EdgeUser)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *NurseMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.historytaking))
		for id := range m.historytaking {
			ids = append(ids, id)
		}
		return ids
	case nurse.EdgeUser:
		if id := m.user; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *NurseMutation) RemovedEdges() []string {
	edges := make([]string, 0, 2)
	if m.removedhistorytaking != nil {
		edges = append(edges, nurse.EdgeHistorytaking)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *NurseMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case nurse.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.removedhistorytaking))
		for id := range m.removedhistorytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *NurseMutation) ClearedEdges() []string {
	edges := make([]string, 0, 2)
	if m.cleareduser {
		edges = append(edges, nurse.EdgeUser)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *NurseMutation) EdgeCleared(name string) bool {
	switch name {
	case nurse.EdgeUser:
		return m.cleareduser
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *NurseMutation) ClearEdge(name string) error {
	switch name {
	case nurse.EdgeUser:
		m.ClearUser()
		return nil
	}
	return fmt.Errorf("unknown Nurse unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *NurseMutation) ResetEdge(name string) error {
	switch name {
	case nurse.EdgeHistorytaking:
		m.ResetHistorytaking()
		return nil
	case nurse.EdgeUser:
		m.ResetUser()
		return nil
	}
	return fmt.Errorf("unknown Nurse edge %s", name)
}

// PatientrecordMutation represents an operation that mutate the Patientrecords
// nodes in the graph.
type PatientrecordMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	_Name                *string
	clearedFields        map[string]struct{}
	historytaking        map[int]struct{}
	removedhistorytaking map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Patientrecord, error)
}

var _ ent.Mutation = (*PatientrecordMutation)(nil)

// patientrecordOption allows to manage the mutation configuration using functional options.
type patientrecordOption func(*PatientrecordMutation)

// newPatientrecordMutation creates new mutation for $n.Name.
func newPatientrecordMutation(c config, op Op, opts ...patientrecordOption) *PatientrecordMutation {
	m := &PatientrecordMutation{
		config:        c,
		op:            op,
		typ:           TypePatientrecord,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withPatientrecordID sets the id field of the mutation.
func withPatientrecordID(id int) patientrecordOption {
	return func(m *PatientrecordMutation) {
		var (
			err   error
			once  sync.Once
			value *Patientrecord
		)
		m.oldValue = func(ctx context.Context) (*Patientrecord, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Patientrecord.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withPatientrecord sets the old Patientrecord of the mutation.
func withPatientrecord(node *Patientrecord) patientrecordOption {
	return func(m *PatientrecordMutation) {
		m.oldValue = func(context.Context) (*Patientrecord, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m PatientrecordMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m PatientrecordMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *PatientrecordMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetName sets the Name field.
func (m *PatientrecordMutation) SetName(s string) {
	m._Name = &s
}

// Name returns the Name value in the mutation.
func (m *PatientrecordMutation) Name() (r string, exists bool) {
	v := m._Name
	if v == nil {
		return
	}
	return *v, true
}

// OldName returns the old Name value of the Patientrecord.
// If the Patientrecord object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *PatientrecordMutation) OldName(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldName is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldName requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldName: %w", err)
	}
	return oldValue.Name, nil
}

// ResetName reset all changes of the "Name" field.
func (m *PatientrecordMutation) ResetName() {
	m._Name = nil
}

// AddHistorytakingIDs adds the historytaking edge to Historytaking by ids.
func (m *PatientrecordMutation) AddHistorytakingIDs(ids ...int) {
	if m.historytaking == nil {
		m.historytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.historytaking[ids[i]] = struct{}{}
	}
}

// RemoveHistorytakingIDs removes the historytaking edge to Historytaking by ids.
func (m *PatientrecordMutation) RemoveHistorytakingIDs(ids ...int) {
	if m.removedhistorytaking == nil {
		m.removedhistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhistorytaking[ids[i]] = struct{}{}
	}
}

// RemovedHistorytaking returns the removed ids of historytaking.
func (m *PatientrecordMutation) RemovedHistorytakingIDs() (ids []int) {
	for id := range m.removedhistorytaking {
		ids = append(ids, id)
	}
	return
}

// HistorytakingIDs returns the historytaking ids in the mutation.
func (m *PatientrecordMutation) HistorytakingIDs() (ids []int) {
	for id := range m.historytaking {
		ids = append(ids, id)
	}
	return
}

// ResetHistorytaking reset all changes of the "historytaking" edge.
func (m *PatientrecordMutation) ResetHistorytaking() {
	m.historytaking = nil
	m.removedhistorytaking = nil
}

// Op returns the operation name.
func (m *PatientrecordMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Patientrecord).
func (m *PatientrecordMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *PatientrecordMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m._Name != nil {
		fields = append(fields, patientrecord.FieldName)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *PatientrecordMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case patientrecord.FieldName:
		return m.Name()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *PatientrecordMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case patientrecord.FieldName:
		return m.OldName(ctx)
	}
	return nil, fmt.Errorf("unknown Patientrecord field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientrecordMutation) SetField(name string, value ent.Value) error {
	switch name {
	case patientrecord.FieldName:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetName(v)
		return nil
	}
	return fmt.Errorf("unknown Patientrecord field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *PatientrecordMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *PatientrecordMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *PatientrecordMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Patientrecord numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *PatientrecordMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *PatientrecordMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *PatientrecordMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Patientrecord nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *PatientrecordMutation) ResetField(name string) error {
	switch name {
	case patientrecord.FieldName:
		m.ResetName()
		return nil
	}
	return fmt.Errorf("unknown Patientrecord field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *PatientrecordMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.historytaking != nil {
		edges = append(edges, patientrecord.EdgeHistorytaking)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *PatientrecordMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case patientrecord.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.historytaking))
		for id := range m.historytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *PatientrecordMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedhistorytaking != nil {
		edges = append(edges, patientrecord.EdgeHistorytaking)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *PatientrecordMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case patientrecord.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.removedhistorytaking))
		for id := range m.removedhistorytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *PatientrecordMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *PatientrecordMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *PatientrecordMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Patientrecord unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *PatientrecordMutation) ResetEdge(name string) error {
	switch name {
	case patientrecord.EdgeHistorytaking:
		m.ResetHistorytaking()
		return nil
	}
	return fmt.Errorf("unknown Patientrecord edge %s", name)
}

// SymptomseverityMutation represents an operation that mutate the Symptomseverities
// nodes in the graph.
type SymptomseverityMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	symptomseverity      *string
	clearedFields        map[string]struct{}
	historytaking        map[int]struct{}
	removedhistorytaking map[int]struct{}
	done                 bool
	oldValue             func(context.Context) (*Symptomseverity, error)
}

var _ ent.Mutation = (*SymptomseverityMutation)(nil)

// symptomseverityOption allows to manage the mutation configuration using functional options.
type symptomseverityOption func(*SymptomseverityMutation)

// newSymptomseverityMutation creates new mutation for $n.Name.
func newSymptomseverityMutation(c config, op Op, opts ...symptomseverityOption) *SymptomseverityMutation {
	m := &SymptomseverityMutation{
		config:        c,
		op:            op,
		typ:           TypeSymptomseverity,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withSymptomseverityID sets the id field of the mutation.
func withSymptomseverityID(id int) symptomseverityOption {
	return func(m *SymptomseverityMutation) {
		var (
			err   error
			once  sync.Once
			value *Symptomseverity
		)
		m.oldValue = func(ctx context.Context) (*Symptomseverity, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().Symptomseverity.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withSymptomseverity sets the old Symptomseverity of the mutation.
func withSymptomseverity(node *Symptomseverity) symptomseverityOption {
	return func(m *SymptomseverityMutation) {
		m.oldValue = func(context.Context) (*Symptomseverity, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m SymptomseverityMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m SymptomseverityMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *SymptomseverityMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetSymptomseverity sets the symptomseverity field.
func (m *SymptomseverityMutation) SetSymptomseverity(s string) {
	m.symptomseverity = &s
}

// Symptomseverity returns the symptomseverity value in the mutation.
func (m *SymptomseverityMutation) Symptomseverity() (r string, exists bool) {
	v := m.symptomseverity
	if v == nil {
		return
	}
	return *v, true
}

// OldSymptomseverity returns the old symptomseverity value of the Symptomseverity.
// If the Symptomseverity object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *SymptomseverityMutation) OldSymptomseverity(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldSymptomseverity is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldSymptomseverity requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldSymptomseverity: %w", err)
	}
	return oldValue.Symptomseverity, nil
}

// ResetSymptomseverity reset all changes of the "symptomseverity" field.
func (m *SymptomseverityMutation) ResetSymptomseverity() {
	m.symptomseverity = nil
}

// AddHistorytakingIDs adds the historytaking edge to Historytaking by ids.
func (m *SymptomseverityMutation) AddHistorytakingIDs(ids ...int) {
	if m.historytaking == nil {
		m.historytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.historytaking[ids[i]] = struct{}{}
	}
}

// RemoveHistorytakingIDs removes the historytaking edge to Historytaking by ids.
func (m *SymptomseverityMutation) RemoveHistorytakingIDs(ids ...int) {
	if m.removedhistorytaking == nil {
		m.removedhistorytaking = make(map[int]struct{})
	}
	for i := range ids {
		m.removedhistorytaking[ids[i]] = struct{}{}
	}
}

// RemovedHistorytaking returns the removed ids of historytaking.
func (m *SymptomseverityMutation) RemovedHistorytakingIDs() (ids []int) {
	for id := range m.removedhistorytaking {
		ids = append(ids, id)
	}
	return
}

// HistorytakingIDs returns the historytaking ids in the mutation.
func (m *SymptomseverityMutation) HistorytakingIDs() (ids []int) {
	for id := range m.historytaking {
		ids = append(ids, id)
	}
	return
}

// ResetHistorytaking reset all changes of the "historytaking" edge.
func (m *SymptomseverityMutation) ResetHistorytaking() {
	m.historytaking = nil
	m.removedhistorytaking = nil
}

// Op returns the operation name.
func (m *SymptomseverityMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (Symptomseverity).
func (m *SymptomseverityMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *SymptomseverityMutation) Fields() []string {
	fields := make([]string, 0, 1)
	if m.symptomseverity != nil {
		fields = append(fields, symptomseverity.FieldSymptomseverity)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *SymptomseverityMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case symptomseverity.FieldSymptomseverity:
		return m.Symptomseverity()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *SymptomseverityMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case symptomseverity.FieldSymptomseverity:
		return m.OldSymptomseverity(ctx)
	}
	return nil, fmt.Errorf("unknown Symptomseverity field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SymptomseverityMutation) SetField(name string, value ent.Value) error {
	switch name {
	case symptomseverity.FieldSymptomseverity:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetSymptomseverity(v)
		return nil
	}
	return fmt.Errorf("unknown Symptomseverity field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *SymptomseverityMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *SymptomseverityMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *SymptomseverityMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown Symptomseverity numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *SymptomseverityMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *SymptomseverityMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *SymptomseverityMutation) ClearField(name string) error {
	return fmt.Errorf("unknown Symptomseverity nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *SymptomseverityMutation) ResetField(name string) error {
	switch name {
	case symptomseverity.FieldSymptomseverity:
		m.ResetSymptomseverity()
		return nil
	}
	return fmt.Errorf("unknown Symptomseverity field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *SymptomseverityMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.historytaking != nil {
		edges = append(edges, symptomseverity.EdgeHistorytaking)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *SymptomseverityMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case symptomseverity.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.historytaking))
		for id := range m.historytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *SymptomseverityMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	if m.removedhistorytaking != nil {
		edges = append(edges, symptomseverity.EdgeHistorytaking)
	}
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *SymptomseverityMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	case symptomseverity.EdgeHistorytaking:
		ids := make([]ent.Value, 0, len(m.removedhistorytaking))
		for id := range m.removedhistorytaking {
			ids = append(ids, id)
		}
		return ids
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *SymptomseverityMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *SymptomseverityMutation) EdgeCleared(name string) bool {
	switch name {
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *SymptomseverityMutation) ClearEdge(name string) error {
	switch name {
	}
	return fmt.Errorf("unknown Symptomseverity unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *SymptomseverityMutation) ResetEdge(name string) error {
	switch name {
	case symptomseverity.EdgeHistorytaking:
		m.ResetHistorytaking()
		return nil
	}
	return fmt.Errorf("unknown Symptomseverity edge %s", name)
}

// UserMutation represents an operation that mutate the Users
// nodes in the graph.
type UserMutation struct {
	config
	op                   Op
	typ                  string
	id                   *int
	email                *string
	password             *string
	clearedFields        map[string]struct{}
	historytaking        *int
	clearedhistorytaking bool
	done                 bool
	oldValue             func(context.Context) (*User, error)
}

var _ ent.Mutation = (*UserMutation)(nil)

// userOption allows to manage the mutation configuration using functional options.
type userOption func(*UserMutation)

// newUserMutation creates new mutation for $n.Name.
func newUserMutation(c config, op Op, opts ...userOption) *UserMutation {
	m := &UserMutation{
		config:        c,
		op:            op,
		typ:           TypeUser,
		clearedFields: make(map[string]struct{}),
	}
	for _, opt := range opts {
		opt(m)
	}
	return m
}

// withUserID sets the id field of the mutation.
func withUserID(id int) userOption {
	return func(m *UserMutation) {
		var (
			err   error
			once  sync.Once
			value *User
		)
		m.oldValue = func(ctx context.Context) (*User, error) {
			once.Do(func() {
				if m.done {
					err = fmt.Errorf("querying old values post mutation is not allowed")
				} else {
					value, err = m.Client().User.Get(ctx, id)
				}
			})
			return value, err
		}
		m.id = &id
	}
}

// withUser sets the old User of the mutation.
func withUser(node *User) userOption {
	return func(m *UserMutation) {
		m.oldValue = func(context.Context) (*User, error) {
			return node, nil
		}
		m.id = &node.ID
	}
}

// Client returns a new `ent.Client` from the mutation. If the mutation was
// executed in a transaction (ent.Tx), a transactional client is returned.
func (m UserMutation) Client() *Client {
	client := &Client{config: m.config}
	client.init()
	return client
}

// Tx returns an `ent.Tx` for mutations that were executed in transactions;
// it returns an error otherwise.
func (m UserMutation) Tx() (*Tx, error) {
	if _, ok := m.driver.(*txDriver); !ok {
		return nil, fmt.Errorf("ent: mutation is not running in a transaction")
	}
	tx := &Tx{config: m.config}
	tx.init()
	return tx, nil
}

// ID returns the id value in the mutation. Note that, the id
// is available only if it was provided to the builder.
func (m *UserMutation) ID() (id int, exists bool) {
	if m.id == nil {
		return
	}
	return *m.id, true
}

// SetEmail sets the email field.
func (m *UserMutation) SetEmail(s string) {
	m.email = &s
}

// Email returns the email value in the mutation.
func (m *UserMutation) Email() (r string, exists bool) {
	v := m.email
	if v == nil {
		return
	}
	return *v, true
}

// OldEmail returns the old email value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldEmail(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldEmail is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldEmail requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldEmail: %w", err)
	}
	return oldValue.Email, nil
}

// ResetEmail reset all changes of the "email" field.
func (m *UserMutation) ResetEmail() {
	m.email = nil
}

// SetPassword sets the password field.
func (m *UserMutation) SetPassword(s string) {
	m.password = &s
}

// Password returns the password value in the mutation.
func (m *UserMutation) Password() (r string, exists bool) {
	v := m.password
	if v == nil {
		return
	}
	return *v, true
}

// OldPassword returns the old password value of the User.
// If the User object wasn't provided to the builder, the object is fetched
// from the database.
// An error is returned if the mutation operation is not UpdateOne, or database query fails.
func (m *UserMutation) OldPassword(ctx context.Context) (v string, err error) {
	if !m.op.Is(OpUpdateOne) {
		return v, fmt.Errorf("OldPassword is allowed only on UpdateOne operations")
	}
	if m.id == nil || m.oldValue == nil {
		return v, fmt.Errorf("OldPassword requires an ID field in the mutation")
	}
	oldValue, err := m.oldValue(ctx)
	if err != nil {
		return v, fmt.Errorf("querying old value for OldPassword: %w", err)
	}
	return oldValue.Password, nil
}

// ResetPassword reset all changes of the "password" field.
func (m *UserMutation) ResetPassword() {
	m.password = nil
}

// SetHistorytakingID sets the historytaking edge to Nurse by id.
func (m *UserMutation) SetHistorytakingID(id int) {
	m.historytaking = &id
}

// ClearHistorytaking clears the historytaking edge to Nurse.
func (m *UserMutation) ClearHistorytaking() {
	m.clearedhistorytaking = true
}

// HistorytakingCleared returns if the edge historytaking was cleared.
func (m *UserMutation) HistorytakingCleared() bool {
	return m.clearedhistorytaking
}

// HistorytakingID returns the historytaking id in the mutation.
func (m *UserMutation) HistorytakingID() (id int, exists bool) {
	if m.historytaking != nil {
		return *m.historytaking, true
	}
	return
}

// HistorytakingIDs returns the historytaking ids in the mutation.
// Note that ids always returns len(ids) <= 1 for unique edges, and you should use
// HistorytakingID instead. It exists only for internal usage by the builders.
func (m *UserMutation) HistorytakingIDs() (ids []int) {
	if id := m.historytaking; id != nil {
		ids = append(ids, *id)
	}
	return
}

// ResetHistorytaking reset all changes of the "historytaking" edge.
func (m *UserMutation) ResetHistorytaking() {
	m.historytaking = nil
	m.clearedhistorytaking = false
}

// Op returns the operation name.
func (m *UserMutation) Op() Op {
	return m.op
}

// Type returns the node type of this mutation (User).
func (m *UserMutation) Type() string {
	return m.typ
}

// Fields returns all fields that were changed during
// this mutation. Note that, in order to get all numeric
// fields that were in/decremented, call AddedFields().
func (m *UserMutation) Fields() []string {
	fields := make([]string, 0, 2)
	if m.email != nil {
		fields = append(fields, user.FieldEmail)
	}
	if m.password != nil {
		fields = append(fields, user.FieldPassword)
	}
	return fields
}

// Field returns the value of a field with the given name.
// The second boolean value indicates that this field was
// not set, or was not define in the schema.
func (m *UserMutation) Field(name string) (ent.Value, bool) {
	switch name {
	case user.FieldEmail:
		return m.Email()
	case user.FieldPassword:
		return m.Password()
	}
	return nil, false
}

// OldField returns the old value of the field from the database.
// An error is returned if the mutation operation is not UpdateOne,
// or the query to the database was failed.
func (m *UserMutation) OldField(ctx context.Context, name string) (ent.Value, error) {
	switch name {
	case user.FieldEmail:
		return m.OldEmail(ctx)
	case user.FieldPassword:
		return m.OldPassword(ctx)
	}
	return nil, fmt.Errorf("unknown User field %s", name)
}

// SetField sets the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) SetField(name string, value ent.Value) error {
	switch name {
	case user.FieldEmail:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetEmail(v)
		return nil
	case user.FieldPassword:
		v, ok := value.(string)
		if !ok {
			return fmt.Errorf("unexpected type %T for field %s", value, name)
		}
		m.SetPassword(v)
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedFields returns all numeric fields that were incremented
// or decremented during this mutation.
func (m *UserMutation) AddedFields() []string {
	return nil
}

// AddedField returns the numeric value that was in/decremented
// from a field with the given name. The second value indicates
// that this field was not set, or was not define in the schema.
func (m *UserMutation) AddedField(name string) (ent.Value, bool) {
	return nil, false
}

// AddField adds the value for the given name. It returns an
// error if the field is not defined in the schema, or if the
// type mismatch the field type.
func (m *UserMutation) AddField(name string, value ent.Value) error {
	switch name {
	}
	return fmt.Errorf("unknown User numeric field %s", name)
}

// ClearedFields returns all nullable fields that were cleared
// during this mutation.
func (m *UserMutation) ClearedFields() []string {
	return nil
}

// FieldCleared returns a boolean indicates if this field was
// cleared in this mutation.
func (m *UserMutation) FieldCleared(name string) bool {
	_, ok := m.clearedFields[name]
	return ok
}

// ClearField clears the value for the given name. It returns an
// error if the field is not defined in the schema.
func (m *UserMutation) ClearField(name string) error {
	return fmt.Errorf("unknown User nullable field %s", name)
}

// ResetField resets all changes in the mutation regarding the
// given field name. It returns an error if the field is not
// defined in the schema.
func (m *UserMutation) ResetField(name string) error {
	switch name {
	case user.FieldEmail:
		m.ResetEmail()
		return nil
	case user.FieldPassword:
		m.ResetPassword()
		return nil
	}
	return fmt.Errorf("unknown User field %s", name)
}

// AddedEdges returns all edge names that were set/added in this
// mutation.
func (m *UserMutation) AddedEdges() []string {
	edges := make([]string, 0, 1)
	if m.historytaking != nil {
		edges = append(edges, user.EdgeHistorytaking)
	}
	return edges
}

// AddedIDs returns all ids (to other nodes) that were added for
// the given edge name.
func (m *UserMutation) AddedIDs(name string) []ent.Value {
	switch name {
	case user.EdgeHistorytaking:
		if id := m.historytaking; id != nil {
			return []ent.Value{*id}
		}
	}
	return nil
}

// RemovedEdges returns all edge names that were removed in this
// mutation.
func (m *UserMutation) RemovedEdges() []string {
	edges := make([]string, 0, 1)
	return edges
}

// RemovedIDs returns all ids (to other nodes) that were removed for
// the given edge name.
func (m *UserMutation) RemovedIDs(name string) []ent.Value {
	switch name {
	}
	return nil
}

// ClearedEdges returns all edge names that were cleared in this
// mutation.
func (m *UserMutation) ClearedEdges() []string {
	edges := make([]string, 0, 1)
	if m.clearedhistorytaking {
		edges = append(edges, user.EdgeHistorytaking)
	}
	return edges
}

// EdgeCleared returns a boolean indicates if this edge was
// cleared in this mutation.
func (m *UserMutation) EdgeCleared(name string) bool {
	switch name {
	case user.EdgeHistorytaking:
		return m.clearedhistorytaking
	}
	return false
}

// ClearEdge clears the value for the given name. It returns an
// error if the edge name is not defined in the schema.
func (m *UserMutation) ClearEdge(name string) error {
	switch name {
	case user.EdgeHistorytaking:
		m.ClearHistorytaking()
		return nil
	}
	return fmt.Errorf("unknown User unique edge %s", name)
}

// ResetEdge resets all changes in the mutation regarding the
// given edge name. It returns an error if the edge is not
// defined in the schema.
func (m *UserMutation) ResetEdge(name string) error {
	switch name {
	case user.EdgeHistorytaking:
		m.ResetHistorytaking()
		return nil
	}
	return fmt.Errorf("unknown User edge %s", name)
}
